name: "tag version"
description: "Tag package"
inputs:
  module_name:
    description: "The package module name"
    required: true
  jira_token:
    description: "Token to authenticate to Jira"
    required: true
  jira_project_id:
    description: "Jira project id to create release"
    required: true

runs:
  using: "composite"
  steps:
    - name: Checkout sources
      uses: actions/checkout@b4ffde65f46336ab88eb53be808477a3936bae11 # v4.1.1

    - name: Get released versions for components
      run: |
        set -eux
        COMPONENTS_RELEASED=()
        COMPONENTS=("centreon-awie" "centreon-dsm" "centreon-gorgone" "centreon-ha" "centreon-open-tickets" "centreon")
        CURRENT_STABLE_BRANCH_MAJOR_VERSION=""
        NEW_STABLE_TAGS=()
        PREVIOUS_STABLE_TAGS=()

        # Get current stable branch name
        CURRENT_STABLE_BRANCH_MAJOR_VERSION=$(git rev-parse --abbrev-ref HEAD | cut -d '.' -f1,2)
        echo "Curent stable branch major version: $CURRENT_STABLE_BRANCH_MAJOR_VERSION"

        # Get previous version tags for components
        for component in ${COMPONENTS[@]}; do
          MAJOR_VERSION=$(grep -E "MAJOR" .version | cut -d '=' -f2)
          MINOR_VERSION=$(grep -E "MINOR" $component/.version | cut -d '=' -f2)
          PREVIOUS_STABLE_TAGS+=$(git tag -l --sort=-version:refname "$component-$CURRENT_STABLE_BRANCH_MAJOR_VERSION*" | head -n 1)
        done
        echo "Previous releases were: ${PREVIOUS_STABLE_TAGS[*]}

        # Get new version tags for components
        for component in ${COMPONENTS[@]}; do
          MAJOR_VERSION=$(grep -E "MAJOR" .version | cut -d '=' -f2)
          MINOR_VERSION=$(grep -E "MINOR" $component/.version | cut -d '=' -f2)
          NEW_STABLE_TAG="centreon-$component-$MAJOR_VERSION-$MINOR_VERSION"
          NEW_STABLE_TAGS+=$($NEW_STABLE_TAG)
        done

        echo "New releases are: ${NEW_STABLE_TAGS[*]}"

        # Check that NEW_STABLE_TAGS are fully different from PREVIOUS_STABLE_TAGS
        # re use the part from check version ??
        # or use the check-version action after turning this release action into a real workflow ?

        # Create new JIRA versions (old way of doing it)
        # TODO: add a future capacity to determine wether the release is hotfix or standard (using TYPE)

        JIRA_VERSION_DATA="{\"archived\":false,\"releaseDate\":\"$(date +%Y-%m-%d)\",\"name\":\"centreon-${{ inputs.module_name }}-$NEW_VERSION\",\"description\":\"$TYPE:$RELEASE_ID\",\"projectId\":${{ inputs.jira_project_id }},\"released\":false}"
        curl --fail --request POST \
          --url 'https://centreon.atlassian.net/rest/api/3/version' \
          --header 'Authorization: Basic ${{ inputs.jira_token }}' \
          --header 'Accept: application/json' \
          --header 'Content-Type: application/json' \
          --data ''$VERSION_DATA''

      shell: bash

    - name: Add new release tags to stable branch
      run: |
        # Add new stable tags to stable branch
        git config --global user.email "release@centreon.com"
        git config --global user.name "Centreon"

        # Create release tags on git for each release components
        for TAG in ${NEW_STABLE_TAGS[@]}; do
          if [ -z $(git tag --list "$TAG" | head -n 1) ]; then
            git tag -a "$TAG" -m "$TAG"
            git push --follow-tags
            echo "::notice::Tagging branch with $tag."
          else
            echo "::error::Release tag $TAG already exists, exiting."
            exit 1
          fi
        done
      shell: bash

    - name: Create GITHUB releases from new release tags
      run: |
        # Install gh cli
        if ! command -v gh &> /dev/null; then
          echo "Installing GH CLI."
          type -p curl >/dev/null || (sudo apt update && sudo apt install curl -y)
          curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg
          sudo chmod go+r /usr/share/keyrings/githubcli-archive-keyring.gpg
          echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null
          sudo apt update
          sudo apt install gh -y
        else
          echo "GH CLI is already installed."
        fi

        # Create GITHUB release for each release components
      shell: bash

    - name: Create stable JIRA versions from new release tags
      run: |
        set -eux

        # Call JIRA to provide new jira versions to create
        # Webhook url
        JIRA_INCOMING_WEBHOOK="${{ inputs.jira_webhook_url }}"

        # Build JSON structure with released versions
        RELEASE_JSON=$(jq -nc '{componentList: $ARGS.positional}' --args "${NEW_STABLE_TAGS[@]}")

        # Create new JIRA versions (old way of doing it)
        # TODO: add a future capacity to determine wether the release is hotfix or standard (using TYPE)

        JIRA_VERSION_DATA="{\"archived\":false,\"releaseDate\":\"$(date +%Y-%m-%d)\",\"name\":\"centreon-${{ inputs.module_name }}-$NEW_VERSION\",\"description\":\"$TYPE:$RELEASE_ID\",\"projectId\":${{ inputs.jira_project_id }},\"released\":false}"
        curl --fail --request POST \
          --url 'https://centreon.atlassian.net/rest/api/3/version' \
          --header 'Authorization: Basic ${{ inputs.jira_token }}' \
          --header 'Accept: application/json' \
          --header 'Content-Type: application/json' \
          --data ''$VERSION_DATA''

      shell: bash

    - name: Trigger release communication for new releases
      run: |
        set -eux
        # Webhook url
        JIRA_INCOMING_WEBHOOK="${{ inputs.jira_webhook_url }}"

        # Build JSON structure with released versions
        RELEASE_JSON=$(jq -nc '{componentList: $ARGS.positional}' --args "${NEW_STABLE_TAGS[@]}")

        # Call jira webhook to trigger the communication workflow
        # and provide versions data for communication
        curl \
          $JIRA_INCOMING_WEBHOOK \
          -X POST \
          -H 'Content-type: application/json' \
          --data $RELEASE_JSON

      shell: bash