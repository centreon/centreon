name: "release action"
description: "Create git release tags, github releases, jira version and push release communication. "
inputs:
  github_ref_name:
    description: "Github ref name"
    required: true
  module_name:
    description: "The package module name"
    required: true
  jira_token:
    description: "Token to authenticate to Jira"
    required: true
  jira_project_id:
    description: "Jira project id to create release"
    required: true
  jira_webhook_url:
    description: "Jira release webhook"
    required: true

runs:
  using: "composite"
  steps:
    - name: Checkout sources
      uses: actions/checkout@b4ffde65f46336ab88eb53be808477a3936bae11 # v4.1.1

    - name: Get released versions for components
      run: |
        set -eu
        COMPONENTS_RELEASED=()
        COMPONENTS_OSS=("centreon-awie" "centreon-dsm" "centreon-gorgone" "centreon-ha" "centreon-open-tickets" "centreon-web")
        COMPONENTS_MODULES=("centreon-anomaly-detection" "centreon-autodiscovery" "centreon-bam" "centreon-cloud-business-extensions" "centreon-cloud-extensions" "centreon-it-edition-extensions" "centreon-license-manager" "centreon-map" "centreon-mbi" "centreon-pp-manager")
        COMPONENTS_COLLECT=("centreon-collect")
        CURRENT_STABLE_BRANCH_MAJOR_VERSION=""
        declare -a NEW_STABLE_TAGS=()
        declare -a PREVIOUS_STABLE_TAGS=()
        SCOPE_VERSION="OSS"
        MINOR_VERSION_FILE_PATH=".version"

        # Get current stable branch name
        CURRENT_STABLE_BRANCH_MAJOR_VERSION=$(echo ${{ inputs.github_ref_name }} | cut -d '.' -f1,2)
        echo "Curent stable branch major version: $CURRENT_STABLE_BRANCH_MAJOR_VERSION"

        # Get previous version tags for components
        for component in ${COMPONENTS_OSS[@]}; do
          if [[ $component == "centreon-web" ]]; then
            COMPONENT_DIR="centreon"
          else
            COMPONENT_DIR=$component
          fi
          MAJOR_VERSION=$(grep -E "MAJOR" .version | cut -d '=' -f2)
          MINOR_VERSION=$(grep -E "MINOR" $COMPONENT_DIR/.version | cut -d '=' -f2)
          PREVIOUS_STABLE_TAGS+=($(git tag -l --sort=-version:refname "$component-$CURRENT_STABLE_BRANCH_MAJOR_VERSION*" | head -n 1))
        done
        echo "Previous releases were: ${PREVIOUS_STABLE_TAGS[*]}"

        # Get new version tags for components
        for component in ${COMPONENTS_OSS[@]}; do
          if [[ $component == "centreon-web" ]]; then
            COMPONENT_DIR="centreon"
          else
            COMPONENT_DIR=$component
          fi
          MAJOR_VERSION=$(grep -E "MAJOR" .version | cut -d '=' -f2)
          MINOR_VERSION=$(grep -E "MINOR" $COMPONENT_DIR/.version | cut -d '=' -f2)
          NEW_STABLE_TAGS+=("$component-$MAJOR_VERSION.$MINOR_VERSION")
        done

        echo "New releases are: ${NEW_STABLE_TAGS[*]}"

        # TODO: Check that NEW_STABLE_TAGS are fully different from PREVIOUS_STABLE_TAGS
        # re use the part from check version ??
        # or use the check-version action after turning this release action into a real workflow ?

        # Make NEW_STABLE_TAGS available for other steps
        echo "NEW_STABLE_TAGS=${NEW_STABLE_TAGS[*]}" >> "$GITHUB_ENV"
        echo "CURRENT_STABLE_BRANCH_MAJOR_VERSION=$CURRENT_STABLE_BRANCH_MAJOR_VERSION" >> "$GITHUB_ENV"
        echo "SCOPE_VERSION=$SCOPE_VERSION" >> "$GITHUB_ENV"
      shell: bash

    - name: Add new release tags to stable branch
      run: |
        # Add new stable tags to stable branch
        echo "Configuring git."
        git config --global user.email "release@centreon.com"
        git config --global user.name "Centreon"

        # Create release tags on git for each release components
        echo "Creating release tags."
        for TAG in ${NEW_STABLE_TAGS[@]}; do
          if [ -z $(git tag --list "$TAG" | head -n 1) ]; then
            git tag -a "$TAG" -m "$TAG"
            git push --follow-tags
            echo "::notice::Tagging stable branch with $TAG."
          else
            echo "::error::Release tag $TAG already exists, exiting."
            exit 1
          fi
        done
      shell: bash

    - name: Create GITHUB releases from new release tags
      run: |
        # Install gh cli
        echo "Installing GH CLI."
        if ! command -v gh &> /dev/null; then
          echo "Installing GH CLI."
          type -p curl >/dev/null || (sudo apt-get update && sudo apt-get install curl -y)
          curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg
          sudo chmod go+r /usr/share/keyrings/githubcli-archive-keyring.gpg
          echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null
          sudo apt-get update
          sudo apt-get install gh -y
        else
          echo "GH CLI is already installed."
        fi

        # Create GITHUB release for each release components
        echo "Creating GITHUB releases."
        for TAG in ${NEW_STABLE_TAGS[@]}; do
          echo "::notice::Creating GITHUB release with title $TAG for tag $TAG."
          gh release create $TAG --target "${{ inputs.github_ref_name }} --title "$TAG" --verify-tag
        done
      shell: bash

    - name: Create stable JIRA versions from new release tags
      run: |
        set -eu

        # Call JIRA to provide new jira versions to create
        # Webhook url
        JIRA_INCOMING_WEBHOOK="${{ inputs.jira_webhook_url }}"

        # Rebuild NEW_STABLE_TAGS as an array
        for i in ${NEW_STABLE_TAGS[@]}; do
          NEW_RELEASE_TAGS+=("$i")
        done

        # Create new JIRA versions (old way of doing it)
        # TODO: add a future capacity to determine wether the release is hotfix or standard (using TYPE)
        # OR: rely on jira automation to do it (less hassle on github side, and jira knows jira best)

        # Create JIRA version for each released component
        echo "Creating JIRA releases."
        for TAG in ${NEW_RELEASE_TAGS[@]}; do
          echo "::notice::Creating JIRA release $TAG based on git release tag $TAG."

          JIRA_VERSION_DATA="{\"archived\":false,\"releaseDate\":\"$(date +%Y-%m-%d)\",\"name\":\"$TAG\",\"projectId\":${{ inputs.jira_project_id }},\"released\":false}"
          echo "Sending to JIRA release: $JIRA_VERSION_DATA"
          # curl --fail --request POST \
            --url 'https://centreon.atlassian.net/rest/api/3/version' \
            --header 'Authorization: Basic ${{ inputs.jira_token }}' \
            --header 'Accept: application/json' \
            --header 'Content-Type: application/json' \
            --data ''$VERSION_DATA''
        done
      shell: bash

    - name: Trigger release communication for new releases
      run: |
        set -eu
        MAJOR_VERSION=$CURRENT_STABLE_BRANCH_MAJOR_VERSION

        # Webhook url
        JIRA_INCOMING_WEBHOOK="${{ inputs.jira_webhook_url }}"

        # Rebuild NEW_STABLE_TAGS as an array
        for i in ${NEW_STABLE_TAGS[@]}; do
          NEW_RELEASE_TAGS+=("$i")
        done

        # Build JSON structure with released versions
        JSON_TAGS=$(jq -n '{componentList:$ARGS.positional}' --args "${NEW_RELEASE_TAGS[@]}")
        JSON_VERSION_INFO=$(jq -n --arg majorVersion "$MAJOR_VERSION" --arg scopeVersion "$SCOPE_VERSION" '$ARGS.named' )
        RELEASE_JSON=$(echo "$JSON_VERSION_INFO" | jq -c --argjson json_tags "$JSON_TAGS" '. += $json_tags')

        # DEBUG
        echo "JSON_TAGS: \r\n$JSON_TAGS"
        echo "JSON_VERSION_INFO: $JSON_VERSION_INFO"
        echo "Sending to JIRA automation: \r\n$RELEASE_JSON"

        # Call jira webhook to trigger the communication workflow
        # and provide versions data for communication
        curl \
          "$JIRA_INCOMING_WEBHOOK" \
          -X POST \
          -H 'Content-type: application/json' \
          --data "$RELEASE_JSON"

      shell: bash
