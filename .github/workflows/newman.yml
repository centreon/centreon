on:
  workflow_call:
    inputs:
      collection_path:
        required: true
        type: string
      image_name:
        required: true
        type: string
      os:
        required: true
        type: string
      container_name:
        required: true
        type: string
      centreon_url:
        required: true
        type: string
      centreon_image:
        required: true
        type: string
      database_image:
        required: true
        type: string
      dependencies_lock_file:
        required: true
        type: string
      major_version:
        required: true
        type: string
      stability:
        required: true
        type: string
      xray_keys_and_ids:
        description: "The test execution and the test plan keys and ids"
        required: true
        type: string
    secrets:
      registry_username:
        required: true
      registry_password:
        required: true
      client_id:
        required: true
      client_secret:
        required: true
      jira_user:
        required: true
      jira_token_test:
        required: true

jobs:
  newman-test-list:
    runs-on: ubuntu-22.04

    outputs:
      collections: ${{ steps.set_collections.outputs.collections }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@b4ffde65f46336ab88eb53be808477a3936bae11 # v4.1.1

      - name: List Postman Collections and Environments
        id: set_collections
        run: |
          collection_path="${{ inputs.collection_path }}"
          collections=$(find "$collection_path" -type f -name "*.postman_collection.json" -printf "%P\n" | sort | jq -R -s -c 'split("\n")[:-1]')
          echo "collections=$collections" >> $GITHUB_OUTPUT
          echo "GITHUB_OUTPUT contents:"
          cat $GITHUB_OUTPUT

  newman-test-run:
    needs: [newman-test-list]
    if: ${{ !cancelled() && !contains(needs.*.result, 'failure') && !contains(needs.*.result, 'cancelled') }}
    runs-on: ubuntu-22.04
    strategy:
      fail-fast: false
      matrix:
        feature: ${{ fromJson(needs.newman-test-list.outputs.collections) }}

    name: ${{ matrix.feature }}

    defaults:
      run:
        shell: bash
        working-directory: centreon/tests/rest_api
    env:
      IMAGE_TAG: ${{ github.head_ref || github.ref_name }}
      SLIM_IMAGE_NAME: ${{ inputs.image_name }}-slim-${{ inputs.os }}
      CONTAINER_NAME: ${{ inputs.container_name }}
      CENTREON_URL: ${{ inputs.centreon_url }}
      WEB_IMAGE: ${{ inputs.centreon_image }}
      DATABASE_IMAGE: ${{ inputs.database_image }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@b4ffde65f46336ab88eb53be808477a3936bae11 # v4.1.1

      - uses: pnpm/action-setup@fe02b34f77f8bc703788d5817da081398fad5dd2 # v4.0.0
        with:
          version: 8
          run_install: false

      - uses: actions/setup-node@60edb5dd545a775178f52524783378180af0d1f8 # v4.0.2
        with:
          node-version: 20
          cache: pnpm
          cache-dependency-path: ${{ inputs.dependencies_lock_file }}

      - name: Install Dependencies for tests/rest_api
        run: pnpm install --frozen-lockfile
        shell: bash
        env:
          CYPRESS_INSTALL_BINARY: "0"
          PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD: "1"
          PUPPETEER_SKIP_CHROMIUM_DOWNLOAD: "true"

      - name: Login to registry
        uses: docker/login-action@343f7c4344506bcbf9b4de18042ae17996df046d # v3.0.0
        with:
          registry: ${{ vars.DOCKER_INTERNAL_REGISTRY_URL }}
          username: ${{ secrets.registry_username }}
          password: ${{ secrets.registry_password }}

      - name: Restore standard slim image from cache
        id: cache-docker-slim
        uses: actions/cache/restore@13aacd865c20de90d75de3b17ebe84f7a17d57d2 # v4.0.0
        continue-on-error: true
        timeout-minutes: 6
        with:
          path: /tmp/cache/docker-image
          key: docker-image-${{ env.SLIM_IMAGE_NAME }}-${{ env.IMAGE_TAG }}
        env:
          SEGMENT_DOWNLOAD_TIMEOUT_MINS: 5

      - name: Load standard slim image
        if: ${{ steps.cache-docker-slim.outputs.cache-hit == 'true' }}
        run: |
          docker load --input /tmp/cache/docker-image/${{ env.SLIM_IMAGE_NAME }}.tar
          docker tag ${{ env.SLIM_IMAGE_NAME }}:${{ env.IMAGE_TAG }} ${{ vars.DOCKER_INTERNAL_REGISTRY_URL }}/${{ env.SLIM_IMAGE_NAME }}:${{ env.IMAGE_TAG }}
        shell: bash

      - name: Start Centreon Web and database containers
        env:
          MYSQL_IMAGE: ${{ env.DATABASE_IMAGE }}
        run: |
          COLLECTION_DIRECTORY=$(dirname "collections/${{ matrix.feature }}")

          if [[ -f "${COLLECTION_DIRECTORY}/.env" ]]; then
            echo "Using environment file ${COLLECTION_DIRECTORY}/.env"
            cat ${COLLECTION_DIRECTORY}/.env >> ../../../.github/docker/.env
          fi

          docker compose --profile web -f ../../../.github/docker/docker-compose.yml up -d --wait

          if [[ -f "${COLLECTION_DIRECTORY}/setup.sh" ]]; then
            echo "Running script ${COLLECTION_DIRECTORY}/setup.sh ..."
            bash -ex "${COLLECTION_DIRECTORY}/setup.sh"
          fi

          if [[ -f "${COLLECTION_DIRECTORY}/setup-web.sh" ]]; then
            echo "Running script ${COLLECTION_DIRECTORY}/setup-web.sh ..."
            docker compose -f ../../../.github/docker/docker-compose.yml cp ${COLLECTION_DIRECTORY}/setup-web.sh web:/tmp/setup-web.sh
            docker compose -f ../../../.github/docker/docker-compose.yml exec web bash -ex "/tmp/setup-web.sh"
          fi
        shell: bash

      - name: Run Postman Tests and Generate HTML Report
        run: |
          collection_file="collections/${{ matrix.feature }}"
          collection_name=$(basename "$collection_file" .postman_collection.json)
          collection_directory="$(dirname "$collection_file")"
          environment_file=$(find "$collection_directory" -maxdepth 1 -type f -name "*.postman_environment.json")
          if [ -f "$environment_file" ]; then
            echo "Environment: $environment_file"
            pnpm newman run "$collection_file" -e "$environment_file" --working-dir "$collection_directory" --reporters cli,htmlextra,json-summary --reporter-htmlextra-title "$collection_name" --reporter-htmlextra-title "${collection_name// /_}" --reporter-htmlextra-export "newman/${collection_name}.html" --reporter-summary-json-export "postman_summaries/${collection_name}-summary.json"
          else
            echo "The file Environment-Collection.json was not found in the same directory as $collection_file"
            exit 1
          fi
        shell: bash

      - name: Display container logs
        if: failure()
        run: docker compose -f ../../../.github/docker/docker-compose.yml logs

      - name: Replace / with - in the feature path
        id: feature-path
        if: always()
        run: |
          feature_name="${{ matrix.feature }}"
          feature_name_with_dash="${feature_name//\//-}"
          echo "Modified Feature Name: $feature_name_with_dash"
          echo "feature_name_with_dash=$feature_name_with_dash" >> $GITHUB_OUTPUT

      - name: Upload HTML Reports
        if: failure()
        uses: actions/upload-artifact@5d5d22a31266ced268874388b861e4b58bb5c2f3 # v4.3.1
        with:
          name: postman-html-reports-${{ steps.feature-path.outputs.feature_name_with_dash }}
          path: centreon/tests/rest_api/newman/

      - name: Upload test reports
        if: always()
        uses: actions/upload-artifact@5d5d22a31266ced268874388b861e4b58bb5c2f3 # v4.3.1
        with:
          name: newman-${{ inputs.os }}-test-reports-${{ steps.feature-path.outputs.feature_name_with_dash }}
          path: centreon/tests/rest_api/postman_summaries/*.json
          retention-days: 1

  synchronize-with-xray:
    needs: [newman-test-run]
    if: always()
    runs-on: ubuntu-22.04
    steps:
      - uses: actions/checkout@b4ffde65f46336ab88eb53be808477a3936bae11 # v4.1.1

      - name: Generate Xray Token
        id: generate-xray-token
        run: |
          token_response=$(curl -H "Content-Type: application/json" -X POST --data "{\"client_id\": \"${{ secrets.client_id }}\", \"client_secret\": \"${{ secrets.client_secret }}\"}" "https://xray.cloud.getxray.app/api/v1/authenticate")
          xray_token=$(echo "$token_response" | sed -n 's/.*"\(.*\)".*/\1/p')
          echo "xray_token=$xray_token" >> $GITHUB_OUTPUT
        shell: bash

      - name: Download Artifacts
        uses: actions/download-artifact@87c55149d96e628cc2ef7e6fc2aab372015aec85 # v4.1.3
        with:
          pattern: newman-${{ inputs.os }}-test-reports-*
          path: newman-json-test-reports
          merge-multiple: true

      - name: Delete Artifacts
        run: |
          artifact_pattern="newman-${{ inputs.os }}-test-reports-"
          TOKEN="${{ secrets.GITHUB_TOKEN }}"
          artifact_exists=true
          while [ "$artifact_exists" = true ]; do
            artifact_exists=false
            artifacts_response=$(curl -L \
                          -H "Accept: application/vnd.github+json" \
                          -H "Authorization: Bearer $TOKEN" \
                          -H "X-GitHub-Api-Version: 2022-11-28" \
                          "https://api.github.com/repos/${{ github.repository }}/actions/artifacts?per_page=100")
            artifacts=$(echo $artifacts_response | jq -c '.artifacts[]')
            echo "Those are the artifacts : $artifacts"
            while read row; do
              artifact_name=$(echo "$row" | jq -r '.name')
              if [[ "$artifact_name" =~ ^.*"$artifact_pattern".* ]]; then
                artifact_exists=true
                echo "Deleting : $artifact_name"
                artifact_id=$(echo "$row" | jq -r '.id')
                curl -L \
                  -X DELETE \
                  -H "Accept: application/vnd.github+json" \
                  -H "Authorization: Bearer $TOKEN" \
                  -H "X-GitHub-Api-Version: 2022-11-28" \
                  "https://api.github.com/repos/${{ github.repository }}/actions/artifacts/${artifact_id}"
              fi
            done <<< "$artifacts"
          done
          echo "End of Deleting"
        shell: bash

      - name: Extract and Store Summaries
        run: |
          declare -A json_info
          for summary_file in newman-json-test-reports/*.json; do
          summary_content=$(cat "$summary_file" | jq -c '{Name: .Collection.Info.Name, Stats: .Run.Stats, Failures: .Run.Failures}')
          filename=$(basename "$summary_file" .json)
            clean_filename="${filename// /_}"
            clean_filename="${clean_filename//-/_}"
            json_info["$clean_filename"]=$summary_content
          done
          for key in "${!json_info[@]}"; do
            echo "Summary info for $key:"
            echo "${json_info[$key]}"
          done

      - name: Generate and Display Summaries
        if: ${{ contains(needs.newman-test-run.result, 'failure') }}
        run: |
          summaries=""
          has_failures=false
          for summary_file in newman-json-test-reports/*.json; do
              collection_name=$(jq -r '.Collection.Info.Name' "$summary_file")
              total_requests=$(jq -r '.Run.Stats.Requests.total' "$summary_file")
              pending_requests=$(jq -r '.Run.Stats.Requests.pending' "$summary_file")
              failed_requests=$(jq -r '.Run.Stats.Requests.failed' "$summary_file")
              failed_assertions=$(jq -r '.Run.Stats.Assertions.failed' "$summary_file")
              failures=$(jq -r '.Run.Failures' "$summary_file")
              echo "$failures"
              if [ "$failed_requests" -gt 0 ] || [ "$failed_assertions" -gt 0 ]; then
                  has_failures=true  # Set has_failures to true if there are failures
                  summaries+="<table>"
                  summaries+="<tr><th>Collection Name</th><th>Total Requests</th><th>‚è≠Ô∏è Skipped requests</th><th>‚ùå Failed Requests</th><th>‚ùå Failed Assertions</th></tr>"
                  summaries+="<tr><td>$collection_name</td><td>$total_requests</td><td>$pending_requests</td><td>$failed_requests</td><td>$failed_assertions</td></tr>"
                  summaries+="</table>"
                  filtered_failures=$(echo "$failures" | jq -c '.[] | select(.Parent.Name // "" != "" and .Source.Name // "" != "" and .Error.Message // "" != "")')
                  while IFS= read -r row; do
                      parent_name=$(echo "$row" | jq -r '.Parent.Name')
                      source_name=$(echo "$row" | jq -r '.Source.Name')
                      error_message=$(echo "$row" | jq -r '.Error.Message')

                      summaries+="<p><strong>üìÅ Collection name:</strong> $parent_name<br><strong>üì¨ Request name:</strong> $source_name<br><strong>‚ùå Error message:</strong> $error_message</p>"
                  done <<< "$(echo "$filtered_failures")"
              fi
              echo "Processing summary file: $summary_file"
          done

          if [ -n "$summaries" ]; then
              echo -e "$summaries" >> $GITHUB_STEP_SUMMARY
          fi

  regroup-artifacts:
    needs: [newman-test-run]
    if: always()
    runs-on: ubuntu-22.04

    steps:
      - uses: actions/checkout@b4ffde65f46336ab88eb53be808477a3936bae11 # v4.1.1

      - name: Merging Artifacts
        uses: ./.github/actions/merge-artifacts
        if: ${{ contains(needs.newman-test-run.result, 'failure') }}
        with:
          target_name: postman-html-reports
          source_paths: postman-html-reports/**/*.html
          source_name_pattern: postman-html-reports-
          github_token: ${{ secrets.GITHUB_TOKEN }}
